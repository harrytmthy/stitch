# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

Stitch is a lightweight, thread-safe DI-SL (Dependency Injection - Service Locator) hybrid library for Kotlin/JVM that ends the debate of "DI vs SL" once and for all. It offers both compile-time dependency resolution (DI path) and runtime dynamic module registration (SL path), providing 10-25x better performance than Koin while maintaining flexibility.

**Key Innovation**: Unlike pure DI frameworks (Dagger) or pure SLs (Koin), Stitch combines both:
- **DI Path** (recommended): Annotation-based (`@Module`, `@Provides`, `@Inject`) with compile-time graph validation and O(1) lookup via KSP code generation
- **SL Path**: Runtime DSL (`module { }`) for dynamic features requiring runtime module registration/unregistration

Both paths share the same runtime (`Component`) and caches, enabling seamless interoperability.

## Build Commands

```bash
# Build the entire project
./gradlew build

# Build only the stitch library module
./gradlew stitch:build

# Clean build artifacts
./gradlew clean

# Run all tests
./gradlew test

# Run tests for the stitch module only
./gradlew stitch:test

# Run a specific test class
./gradlew stitch:test --tests "com.harrytmthy.stitch.StitchTest"

# Run a specific test method
./gradlew stitch:test --tests "com.harrytmthy.stitch.StitchTest.singleton should return same instance"
```

## Code Quality & Publishing

```bash
# Check API compatibility (binary compatibility validation)
./gradlew stitch:apiCheck

# Update API dump after intentional API changes
./gradlew stitch:apiDump

# Generate documentation with Dokka
./gradlew stitch:dokkaGenerate

# Publish to Maven Local for testing
./gradlew stitch:publishToMavenLocal

# Publish to Maven Central (requires credentials)
./gradlew stitch:publishAndReleaseToMavenCentral
```

## Project Structure

This is a multi-module Gradle project:

- **stitch/** - The core runtime library (publishable artifact)
  - Source: `stitch/src/commonMain/kotlin/` (using Kotlin Multiplatform structure even though currently JVM-only)
  - Tests: `stitch/src/commonTest/kotlin/`
  - Handles both DI and SL dependency resolution at runtime

- **stitch-annotations/** - Annotation definitions for DI path (publishable artifact)
  - Provides `@Module`, `@Provides`, `@Inject`, `@Singleton`, `@Named`, `@Qualifier`
  - Supports both Stitch-native and Dagger/javax.inject annotations

- **stitch-compiler/** - KSP compiler plugin for DI path (publishable artifact)
  - Scans `@Module` classes, `@Provides` methods, and `@Inject` constructors/fields at compile-time
  - Validates dependency graph and detects cycles
  - Generates `DependencyTable` implementation for O(1) lookup
  - Outputs: `com.harrytmthy.stitch.generated.GeneratedDependencyTable` and `initStitch()`

- **app/** - Android sample/demo application
  - Demonstrates both DI and SL path usage
  - Not part of published artifacts

- **build-logic/** - Convention plugins for build configuration
  - Contains custom Gradle plugins: `stitch.jvm`, `stitch.publishing`, `stitch.android.library`

## Core Architecture

### DI-SL Hybrid Model

Stitch uniquely combines compile-time DI with runtime SL in a single unified system:

**Dependency Resolution Order** (`Component.getInternal()`):
1. **Cache Fast-Path** (lines 60-67): Check runtime caches (scoped/singleton) - O(1)
2. **DI Fast-Path** (lines 69-94): Check compile-time generated `DependencyTable` - O(1)
3. **SL Fallback** (lines 96+): Recursively lookup in runtime-registered `Registry` - O(log n)

**Key Innovation**: DI and SL dependencies share the same caches (`Registry.singletons`, `Registry.scoped`), ensuring a single instance is created regardless of which path registered it.

### Registry-Based Dependency Resolution

The architecture centers around a global `Registry` object that stores dependency definitions and instances:

- **Registry** (`stitch/internal/Registry.kt`): Central storage for SL path dependency definitions and shared caches
  - `definitions`: Maps types to their nodes (for SL-registered singletons/factories)
  - `scopedDefinitions`: Maps scope references to type/node mappings (for SL-registered scoped dependencies)
  - `singletons`: Cached singleton instances (shared by both DI and SL paths, thread-safe via ConcurrentHashMap)
  - `scoped`: Cached scoped instances per scope ID (shared by both paths, thread-safe)

- **DependencyTable** (`stitch/internal/DependencyTable.kt`): Interface for compile-time generated DI lookup
  - Implemented by `GeneratedDependencyTable` (generated by `stitch-compiler`)
  - Contains immutable map of `(Class<*>, Qualifier?) -> Node`
  - Registered via `Stitch.registerDependencyTable()` (called by generated `initStitch()`)

### Core Components

1. **Stitch** (`stitch/api/Stitch.kt`): Global entry point
   - `register(modules)`: Registers modules and eagerly instantiates eager singletons
   - `unregister(modules)`: Removes module definitions and clears cached instances
   - `get<T>()`: Retrieves dependencies with optional qualifier/scope
   - `inject<T>()`: Lazy dependency injection

2. **Module** (`stitch/api/Module.kt`): DSL for defining dependencies
   - `singleton {}`: Creates a single shared instance (cached in `Registry.singletons`)
   - `factory {}`: Creates a new instance on each request (no caching)
   - `scoped(scopeRef) {}`: Creates one instance per scope (cached in `Registry.scoped[scopeId]`)
   - Supports `eager = true` for immediate instantiation on registration
   - Supports `forceEager = true` at module level to make all singletons eager

3. **Component** (`stitch/api/Component.kt`): Resolution engine
   - Handles dependency graph traversal and instance creation
   - Manages thread-local resolution stack for cycle detection
   - Implements double-checked locking for thread-safe singleton creation
   - Maintains scope context for scoped dependency resolution

4. **Node** (`stitch/internal/Node.kt`): Internal representation of a dependency definition
   - Contains type, qualifier, definition type (singleton/factory/scoped), and factory function
   - Supports binding to supertypes/interfaces via `bind<T>()`

### Scoping Model

The library uses a ScopeRef-first scoping model (changed from Scope-first in PR #28):

- **ScopeRef** (`stitch/api/Scope.kt`): Value class wrapping a scope name (e.g., "Activity", "ViewModel")
  - Created via `scope("name")` helper
  - Can create multiple `Scope` instances: `scopeRef.newInstance()`
  - Used at definition time: `scoped(scope("Activity")) { ... }`

- **Scope** (`stitch/api/Scope.kt`): Individual scope instance
  - Has unique ID and lifecycle (open/close)
  - `open()`: Allows dependency resolution
  - `close()`: Marks scope as closed and clears all cached instances for this scope ID
  - Attempting to get dependencies from closed scope throws `ScopeClosedException`

**Key insight**: Multiple Scope instances can exist for the same ScopeRef. Each gets a unique ID. When a Scope is closed, only instances cached for that specific scope ID are cleared.

### Dependency Lookup Flow

When `Stitch.get<T>(qualifier, scope)` is called:

1. **Fast-path cache checks** (Component.kt:54-61):
   - Check scoped cache if scope provided
   - Check singleton cache

2. **Node lookup** (Stitch.kt:80-86):
   - For scoped: lookup in `Registry.scopedDefinitions[scopeRef][type][qualifier]`
   - Otherwise: lookup in `Registry.definitions[type][qualifier]`
   - Throws `MissingBindingException` if not found

3. **Alias handling** (Component.kt:67-75):
   - If node type differs from requested type (due to `bind()`), recheck caches with canonical type

4. **Resolution with cycle guard** (Component.kt:78-121):
   - Enter resolution stack (throws `CycleException` if cycle detected)
   - Based on `DefinitionType`:
     - **Factory**: Always create new instance
     - **Scoped**: Double-checked locking in scope-specific cache, maintain scope context during build
     - **Singleton**: Double-checked locking in global singleton cache
   - Exit resolution stack

### Qualifiers

Qualifiers differentiate multiple bindings of the same type:

- Use `Named` value class: `named("prod")`, `named("staging")`
- Custom qualifiers: implement `Qualifier` interface
- Default qualifier (`DefaultQualifier`) used when none specified

### Type Binding

The `bind()` API allows binding implementations to supertypes:

```kotlin
singleton<NetworkService> { NetworkServiceImpl() }.bind<Service>()
```

This registers the binding under both `NetworkService` and `Service`, but instances are cached using the canonical (original) type to avoid duplication.

## Usage Guide

### DI Path (Recommended)

The DI path uses annotations for compile-time dependency graph generation and validation.

**Setup:**
1. Add dependencies to `build.gradle.kts`:
```kotlin
plugins {
    id("com.google.devtools.ksp") version "x.x.x-x.x.x"  // Match Kotlin version
}

dependencies {
    implementation("com.harrytmthy.stitch:stitch:1.0.0")
    implementation("com.harrytmthy.stitch:stitch-annotations:1.0.0")
    ksp("com.harrytmthy.stitch:stitch-compiler:1.0.0")
}
```

2. Define modules using annotations:
```kotlin
@Module
class AppModule {
    @Provides
    @Singleton
    fun provideLogger(): Logger = Logger()

    @Provides
    @Singleton
    fun provideUserRepository(logger: Logger): UserRepository =
        UserRepository(logger)

    @Provides  // Factory (new instance each time)
    fun provideApiService(logger: Logger, @Named("baseUrl") url: String): ApiService =
        ApiService(logger, url)

    @Provides
    @Named("baseUrl")
    @Singleton
    fun provideBaseUrl(): String = "https://api.example.com/"
}
```

3. Initialize during app startup:
```kotlin
fun main() {
    initStitch()  // Generated by KSP compiler
    val repo = Stitch.get<UserRepository>()
}
```

**@Inject Constructor & Field Injection**

For simple cases, use `@Inject` directly on class constructors instead of `@Provides` methods:

```kotlin
// Basic @Inject constructor (singleton)
@Singleton
class Logger @Inject constructor() {
    fun log(message: String) = println("[LOG] $message")
}

// @Inject constructor with dependencies
@Singleton
class UserRepositoryImpl @Inject constructor(
    private val logger: Logger,  // Automatically resolved
) {
    fun getUser(id: Int): String {
        logger.log("Fetching user $id")
        return "User#$id"
    }
}

// Factory (unscoped) - new instance each time
class ApiService @Inject constructor(
    private val logger: Logger,
    @Named("baseUrl") private val baseUrl: String  // Qualified dependency
) {
    fun fetch(endpoint: String): String {
        logger.log("Fetching $baseUrl$endpoint")
        return "Response from $endpoint"
    }
}

// Field injection only (no-arg constructor)
@Singleton
class ViewModel @Inject constructor() {
    @Inject lateinit var repository: UserRepositoryImpl
    @Inject lateinit var cache: CacheService

    fun loadData(): String {
        val user = repository.getUser(1)
        val cached = cache.get("data")
        return "$user - $cached"
    }
}

// Mixed: Constructor + Field injection
@Singleton
class ComplexService @Inject constructor(
    private val logger: Logger  // Constructor injection (preferred for immutable fields)
) {
    @Inject lateinit var cache: CacheService  // Field injection
    @Inject @Named("baseUrl") var baseUrl: String = ""  // Field with qualifier

    fun process(): String {
        logger.log("Processing with $baseUrl")
        return cache.get("key") ?: "default"
    }
}

// @Named on class for multiple bindings of same type
@Named("prod")
class ProdApiClient @Inject constructor()

@Named("staging")
class StagingApiClient @Inject constructor()

// Usage
val prodClient = Stitch.get<ProdApiClient>(named("prod"))
```

**@Inject Requirements:**
- Constructor injection: Mark constructor with `@Inject` (only one per class)
- Field injection: Field must be `var` or `lateinit var` (not `val`)
- Field injection: Field cannot be `private` (generated code needs access)
- Lifecycle: Use `@Singleton` on the class for singleton, omit for factory
- Qualifiers: Use `@Named` on constructor parameters, fields, or the class itself

**When to use @Provides vs @Inject:**
- **Use @Inject** for simple classes you control (reduces boilerplate)
- **Use @Provides** for:
  - Interface bindings (e.g., `UserRepository` -> `UserRepositoryImpl`)
  - External classes you don't control
  - Complex instantiation logic
  - Configuration values (e.g., base URLs, API keys)
  - Multiple bindings of same type with different qualifiers

**Benefits:**
- Compile-time cycle detection (catches errors before runtime)
- O(1) dependency lookup (vs. O(log n) for SL path)
- IDE navigation from usage to provider
- Supports both Stitch annotations and Dagger/javax.inject annotations
- Constructor and field injection with `@Inject`

**Limitations (v1.0):**
- Scoped dependencies not supported in DI path (use SL path for scopes)

### SL Path

The SL path uses a runtime DSL for dynamic module registration/unregistration.

**Use Cases:**
- Dynamic features that need runtime module registration/unregistration
- Scoped dependencies (until DI path adds scope support in v1.1)
- Migration from Koin or other SL frameworks

**Usage:**
```kotlin
val appModule = module {
    singleton { Logger() }
    singleton { UserRepository(get()) }
    factory { ApiService(get(), get(named("baseUrl"))) }
    singleton(named("baseUrl")) { "https://api.example.com/" }
}

fun main() {
    Stitch.register(appModule)
    val repo = Stitch.get<UserRepository>()
}
```

**Scoped Dependencies:**
```kotlin
val activityScopeRef = scope("Activity")

val activityModule = module {
    scoped(activityScopeRef) { ActivityViewModel(get()) }
}

Stitch.register(activityModule)

val activityScope = activityScopeRef.newInstance()
activityScope.open()
val viewModel = activityScope.get<ActivityViewModel>()
activityScope.close()  // Clears cached instances
```

### Hybrid Usage

DI and SL paths can be used together seamlessly:

```kotlin
// DI path module
@Module
class InfraModule {
    @Provides @Singleton
    fun provideLogger(): Logger = Logger()
}

// SL path module
val featureModule = module {
    factory { FeatureViewModel(get()) }  // get() resolves Logger from DI path!
}

fun main() {
    initStitch()  // Register DI modules
    Stitch.register(featureModule)  // Register SL modules
}
```

**Resolution behavior:**
- Dependencies are first checked in DI table, then fall back to SL registry
- All dependencies share the same cache, ensuring singletons remain single

## Testing Guidelines

- All tests use `@BeforeTest` to call `Stitch.unregisterAll()` to reset global state
- Test structure in `stitch/src/commonTest/kotlin/`:
  - `StitchTest.kt`: Main functionality tests
  - `TestFixtures.kt`: Shared test classes and utilities
- Use Kotlin test framework (`kotlin.test`)
- Binary compatibility is enforced via `apiCheck` - update `stitch/api/stitch.api` when making intentional API changes

## Code Style

- Configured via `.editorconfig` with ktlint rules
- Trailing commas enabled for Kotlin files
- Several ktlint rules disabled (see `.editorconfig` for specifics)
- License header required on all source files (Apache 2.0)

## Important Implementation Notes

1. **Thread Safety**: The library uses `ConcurrentHashMap` for all caches and synchronized blocks for singleton/scoped instance creation to ensure thread-safe operation.

2. **Reified APIs**: Public APIs use `inline` + `reified` generics (`get<T>()`) which delegate to `@PublishedApi internal` functions accepting `Class<T>` for the actual implementation.

3. **API Compatibility**: This library uses Kotlin Binary Compatibility Validator. Any public API changes must be reflected in `stitch/api/stitch.api` via `./gradlew stitch:apiDump`.

4. **Source Structure**: Uses Kotlin Multiplatform directory structure (`commonMain`, `commonTest`) even though currently JVM-only, likely for future multiplatform support.

5. **Gradle Convention Plugins**: Build configuration is centralized in `build-logic/convention/` to share common setup across modules.
