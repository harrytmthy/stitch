/*
 * Copyright 2026 Harry Timothy Tumalewa
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.harrytmthy.stitch.compiler

import com.google.devtools.ksp.processing.CodeGenerator
import com.google.devtools.ksp.processing.Dependencies
import com.harrytmthy.stitch.annotations.Contribute
import com.harrytmthy.stitch.compiler.StitchSymbolProcessor.Companion.GENERATED_PACKAGE_NAME
import com.squareup.kotlinpoet.AnnotationSpec
import com.squareup.kotlinpoet.ClassName
import com.squareup.kotlinpoet.CodeBlock
import com.squareup.kotlinpoet.FileSpec
import com.squareup.kotlinpoet.TypeSpec
import java.io.OutputStreamWriter

class ContributionCodeGenerator(private val codeGenerator: CodeGenerator) {

    fun generate(moduleName: String, moduleKey: String, registry: Registry) {
        val sortedBindings = registry.getSortedBindingsWithId()
        val contributedBindings = buildContributedBindings(sortedBindings)
        val contributeAnnotation = AnnotationSpec.builder(Contribute::class).apply {
            addMember("moduleKey = %S", moduleKey)
            addMember("bindings = %L", contributedBindings)
            if (registry.requestedBindingsByClass.isNotEmpty()) {
                val sortedRequestedBindings = registry.getSortedRequestedBindings()
                val requesters = buildBindingRequesters(sortedBindings, sortedRequestedBindings)
                addMember("requesters = %L", requesters)
            } else {
                addMember("requesters = []")
            }
            if (registry.customScopeByCanonicalName.isNotEmpty()) {
                val sortedCustomScopes = registry.getSortedRegisteredScopesWithId()
                val scopes = buildRegisteredScopes(sortedCustomScopes, registry.scopeDependencies)
                addMember("scopes = %L", scopes)
            } else {
                addMember("scopes = []")
            }
        }.build()
        val fileName = "Generated${moduleName.toPascalModuleName()}Contribution_$moduleKey"
        val outputObject = TypeSpec.objectBuilder(fileName)
            .addAnnotation(contributeAnnotation)
            .build()
        val file = FileSpec.builder(GENERATED_PACKAGE_NAME, fileName)
            .addFileComment("Generated by Stitch KSP Compiler - DO NOT EDIT")
            .addImport("com.harrytmthy.stitch.annotations", "Contribute")
            .addType(outputObject)
            .build()
        val outputStream = codeGenerator.createNewFile(
            dependencies = Dependencies(aggregating = true),
            packageName = GENERATED_PACKAGE_NAME,
            fileName = fileName,
        )
        OutputStreamWriter(outputStream).use(file::writeTo)
    }

    private fun buildContributedBindings(sortedBindings: Map<Binding, Int>): CodeBlock {
        val contributedBindingClass = ClassName(
            "com.harrytmthy.stitch.annotations",
            "ContributedBinding",
        )
        return CodeBlock.builder().apply {
            add("[\n")
            indent()
            sortedBindings.forEach { (binding, id) ->
                add("%T(\n", contributedBindingClass)
                indent()
                add("id = %L,\n", id)
                add("type = %S,\n", binding.type)
                add("qualifier = %S,\n", binding.qualifier?.encode().orEmpty())
                if (binding is ProvidedBinding) {
                    add("scope = %S,\n", binding.scope?.toString().orEmpty())
                    add("location = %S,\n", binding.location)
                    add("alias = %L,\n", binding.alias)
                    val dependencies = binding.dependencies?.map(sortedBindings::getValue)
                        ?.sorted()
                        ?.joinToString(", ")
                        .orEmpty()
                    add("dependsOn = [%L],\n", dependencies)
                } else {
                    add("scope = \"\",\n")
                    add("location = \"\",\n")
                    add("alias = false,\n")
                    add("dependsOn = [],\n")
                }
                unindent()
                add("),\n")
            }
            unindent()
            add("]")
        }.build()
    }

    private fun buildBindingRequesters(
        sortedBindings: Map<Binding, Int>,
        sortedRequestedBindings: Map<String, List<RequestedBinding>>,
    ): CodeBlock {
        val bindingRequesterClass = ClassName(
            "com.harrytmthy.stitch.annotations",
            "BindingRequester",
        )
        val requestedFieldClass = ClassName(
            "com.harrytmthy.stitch.annotations",
            "RequestedField",
        )
        return CodeBlock.builder().apply {
            add("[\n")
            indent()
            sortedRequestedBindings.forEach { (className, fields) ->
                add("%T(\n", bindingRequesterClass)
                indent()
                add("name = %S,\n", className)
                add("fields = [\n")
                indent()
                fields.forEach { requested ->
                    val id = sortedBindings.getValue(requested)
                    add("%T(\n", requestedFieldClass)
                    indent()
                    add("bindingId = %L,\n", id)
                    add("fieldName = %S,\n", requested.fieldName)
                    unindent()
                    add("),\n")
                }
                unindent()
                add("],\n")
                unindent()
                add("),\n")
            }
            unindent()
            add("]")
        }.build()
    }

    private fun buildRegisteredScopes(
        sortedCustomScopes: Map<Scope.Custom, Int>,
        scopeDependencies: Map<Scope, Scope>,
    ): CodeBlock {
        val registeredScopeClass = ClassName(
            "com.harrytmthy.stitch.annotations",
            "RegisteredScope",
        )
        return CodeBlock.builder().apply {
            add("[\n")
            indent()
            sortedCustomScopes.forEach { (scope, id) ->
                add("%T(\n", registeredScopeClass)
                indent()
                add("id = %L,\n", id)
                add("canonicalName = %S,\n", scope.canonicalName)
                add("qualifiedName = %S,\n", scope.qualifiedName)
                add("location = %S,\n", scope.location)
                val dependency = scopeDependencies[scope] as? Scope.Custom
                add("dependsOn = %L,\n", sortedCustomScopes.getOrDefault(dependency, 0))
                unindent()
                add("),\n")
            }
            unindent()
            add("]")
        }.build()
    }

    /**
     * Returns sorted bindings by stable IDs, which includes:
     * - provided bindings + their dependencies
     * - requested bindings
     */
    private fun Registry.getSortedBindingsWithId(): Map<Binding, Int> {
        val bindings = LinkedHashSet<Binding>()
        bindings += providedBindings.values
        providedBindings.values.forEach { it.dependencies?.let(bindings::addAll) }
        bindings += requestedBindingsByClass.values.flatten()
        bindings += missingBindings
        var nextId = 1
        return bindings.sortedWith(compareBy({ it.type }, { it.qualifier?.toString().orEmpty() }))
            .associateWith { nextId++ }
    }

    /**
     * Produces stable ordering for Gradle cache hits.
     */
    private fun Registry.getSortedRequestedBindings(): Map<String, List<RequestedBinding>> =
        requestedBindingsByClass.toSortedMap() // sort by requester's FQN
            .mapValues { (_, fields) ->
                val comparator = compareBy<RequestedBinding>(
                    { it.fieldName },
                    { it.type },
                    { it.qualifier?.toString().orEmpty() },
                )
                fields.sortedWith(comparator)
            }

    /**
     * Returns sorted bindings by stable IDs.
     */
    private fun Registry.getSortedRegisteredScopesWithId(): Map<Scope.Custom, Int> {
        var nextId = 1
        return customScopeByCanonicalName.values.sortedWith(compareBy { it.canonicalName })
            .associateWith { nextId++ }
    }

    private fun String.toPascalModuleName(): String =
        Regex("\\p{L}+")
            .findAll(this)
            .joinToString("") { match ->
                match.value
                    .lowercase()
                    .replaceFirstChar(Char::uppercase)
            }
            .ifBlank { error("Unable to transform '$this' to pascal case") }
}
