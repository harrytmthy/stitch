/*
 * Copyright 2026 Harry Timothy Tumalewa
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.harrytmthy.stitch.compiler

import com.google.devtools.ksp.processing.CodeGenerator
import com.google.devtools.ksp.processing.Dependencies
import com.harrytmthy.stitch.annotations.Contribute
import com.squareup.kotlinpoet.AnnotationSpec
import com.squareup.kotlinpoet.ClassName
import com.squareup.kotlinpoet.CodeBlock
import com.squareup.kotlinpoet.FileSpec
import com.squareup.kotlinpoet.TypeSpec
import java.io.OutputStreamWriter
import java.security.MessageDigest

class ContributionCodeGenerator(private val codeGenerator: CodeGenerator) {

    fun generate(moduleName: String, registry: Registry) {
        val sortedBindings = registry.getSortedBindingsWithId()
        val contributedBindings = buildContributedBindings(sortedBindings)
        val contributeAnnotation = AnnotationSpec.builder(Contribute::class).apply {
            addMember("bindings = %L", contributedBindings)
            if (registry.requestedBindingsByClass.isNotEmpty()) {
                val sortedRequestedBindings = registry.getSortedRequestedBindings()
                val requesters = buildBindingRequesters(sortedBindings, sortedRequestedBindings)
                addMember("requesters = %L", requesters)
            }
        }.build()
        val packageName = "com.harrytmthy.stitch.generated"
        val moduleKey = moduleName.toModuleKey()
        val fileName = "Generated${moduleName.toPascalModuleName()}Contribution_$moduleKey"
        val outputObject = TypeSpec.objectBuilder(fileName)
            .addAnnotation(contributeAnnotation)
            .build()
        val file = FileSpec.builder(packageName, fileName)
            .addFileComment("Generated by Stitch KSP Compiler - DO NOT EDIT")
            .addImport("com.harrytmthy.stitch.annotations", "Contribute")
            .addType(outputObject)
            .build()
        val outputStream = codeGenerator.createNewFile(
            dependencies = Dependencies(aggregating = true),
            packageName = packageName,
            fileName = fileName,
        )
        OutputStreamWriter(outputStream).use(file::writeTo)
    }

    private fun buildContributedBindings(sortedBindings: Map<Binding, Int>): CodeBlock {
        val contributedBindingClass = ClassName(
            "com.harrytmthy.stitch.annotations",
            "ContributedBinding",
        )
        return CodeBlock.builder().apply {
            add("[\n")
            indent()
            sortedBindings.forEach { (binding, id) ->
                add("%T(\n", contributedBindingClass)
                indent()
                add("id = %L,\n", id)
                add("type = %S,\n", binding.type)
                binding.qualifier?.let { add("qualifier = %S,\n", it.encode()) }
                if (binding is ProvidedBinding) {
                    binding.scope?.let { add("scope = %S,\n", it) }
                    add("location = %S,\n", binding.location)
                    add("alias = %L,\n", binding.alias)
                    binding.dependencies?.map(sortedBindings::getValue)
                        ?.sorted()
                        ?.let { add("dependsOn = intArrayOf(%L),\n", it.joinToString(", ")) }
                }
                unindent()
                add("),\n")
            }
            unindent()
            add("]")
        }.build()
    }

    private fun buildBindingRequesters(
        sortedBindings: Map<Binding, Int>,
        sortedRequestedBindings: Map<String, List<RequestedBinding>>,
    ): CodeBlock {
        val bindingRequesterClass = ClassName(
            "com.harrytmthy.stitch.annotations",
            "BindingRequester",
        )
        val requestedFieldClass = ClassName(
            "com.harrytmthy.stitch.annotations",
            "RequestedField",
        )
        return CodeBlock.builder().apply {
            add("[\n")
            indent()
            sortedRequestedBindings.forEach { (className, fields) ->
                add("%T(\n", bindingRequesterClass)
                indent()
                add("name = %S,\n", className)
                add("fields = [\n")
                indent()
                fields.forEach { requested ->
                    val id = sortedBindings.getValue(requested)
                    add("%T(\n", requestedFieldClass)
                    indent()
                    add("bindingId = %L,\n", id)
                    add("fieldName = %S,\n", requested.fieldName)
                    unindent()
                    add("),\n")
                }
                unindent()
                add("],\n")
                unindent()
                add("),\n")
            }
            unindent()
            add("]")
        }.build()
    }

    /**
     * Returns sorted bindings by stable IDs, which includes:
     * - provided bindings + their dependencies
     * - requested bindings
     */
    private fun Registry.getSortedBindingsWithId(): Map<Binding, Int> {
        val bindings = LinkedHashSet<Binding>()
        bindings += providedBindings.values
        providedBindings.values.forEach { it.dependencies?.let(bindings::addAll) }
        bindings += requestedBindingsByClass.values.flatten()
        bindings += missingBindings
        var nextId = 1
        return bindings.sortedWith(compareBy({ it.type }, { it.qualifier?.toString().orEmpty() }))
            .associateWith { nextId++ }
    }

    /**
     * Produces stable ordering for Gradle cache hits.
     */
    private fun Registry.getSortedRequestedBindings(): Map<String, List<RequestedBinding>> =
        requestedBindingsByClass.toSortedMap() // sort by requester's FQN
            .mapValues { (_, fields) ->
                val comparator = compareBy<RequestedBinding>(
                    { it.fieldName },
                    { it.type },
                    { it.qualifier?.toString().orEmpty() },
                )
                fields.sortedWith(comparator)
            }

    /**
     * Produces a stable 6-byte hex key used to disambiguate generated contribution names
     * for modules that normalize to the same PascalCase name.
     */
    private fun String.toModuleKey(): String {
        val digest = MessageDigest.getInstance("SHA-256").digest(toByteArray())
        return digest.take(6).joinToString("") { "%02X".format(it.toInt() and 0xFF) }
    }

    private fun String.toPascalModuleName(): String =
        Regex("\\p{L}+")
            .findAll(this)
            .joinToString("") { match ->
                match.value
                    .lowercase()
                    .replaceFirstChar(Char::uppercase)
            }
            .ifBlank { error("Unable to transform '$this' to pascal case") }
}
