/*
 * Copyright 2025 Harry Timothy Tumalewa
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.harrytmthy.stitch.compiler

import com.google.devtools.ksp.processing.Dependencies
import com.google.devtools.ksp.processing.KSPLogger
import com.google.devtools.ksp.symbol.ClassKind
import com.google.devtools.ksp.symbol.KSClassDeclaration
import com.google.devtools.ksp.symbol.KSFunctionDeclaration
import com.google.devtools.ksp.symbol.KSType
import com.squareup.kotlinpoet.ClassName
import com.squareup.kotlinpoet.CodeBlock
import com.squareup.kotlinpoet.FileSpec
import com.squareup.kotlinpoet.FunSpec
import com.squareup.kotlinpoet.KModifier
import com.squareup.kotlinpoet.ParameterSpec
import com.squareup.kotlinpoet.ParameterizedTypeName.Companion.parameterizedBy
import com.squareup.kotlinpoet.PropertySpec
import com.squareup.kotlinpoet.TypeSpec
import com.squareup.kotlinpoet.TypeVariableName
import com.squareup.kotlinpoet.asClassName
import com.squareup.kotlinpoet.buildCodeBlock
import java.io.OutputStreamWriter
import com.google.devtools.ksp.processing.CodeGenerator as KspCodeGenerator

/**
 * Generates the DependencyTable implementation using direct method calls (Dagger-style).
 */
class StitchCodeGenerator(
    private val codeGenerator: KspCodeGenerator,
    private val logger: KSPLogger,
) {

    private companion object {
        const val GENERATED_PACKAGE = "com.harrytmthy.stitch.generated"
        const val DI_COMPONENT_NAME = "StitchDiComponent"
        const val GENERATED_CLASS_NAME = "GeneratedDependencyTable"
    }

    fun generateDependencyTable(nodes: List<DependencyNode>, entryPoints: List<EntryPointInfo>) {
        logger.info("Stitch: Generating DependencyTable with ${nodes.size} bindings and ${entryPoints.size} entry points")

        val dependencies = Dependencies(
            aggregating = true,
            sources = nodes.flatMap { listOf(it.providerModule.containingFile, it.providerFunction.containingFile) }
                .plus(entryPoints.map { it.classDeclaration.containingFile })
                .filterNotNull()
                .distinct()
                .toTypedArray(),
        )

        // Generate 3 separate files
        generateDiComponentFile(nodes, entryPoints, dependencies)
        generateTableAdapterFile(nodes, entryPoints, dependencies)
        generateInitializerFile(dependencies)

        // Generate ServiceLoader provider configuration
        generateServiceLoaderConfig(dependencies)

        // Generate StitchXxxInjector objects for performance path
        generateInjectorObjects(entryPoints, dependencies)

        logger.info("Stitch: Generated 3 files: StitchDiComponent, GeneratedDependencyTable, GeneratedStitchInitializer")
    }

    private fun generateDiComponentFile(
        nodes: List<DependencyNode>,
        entryPoints: List<EntryPointInfo>,
        dependencies: Dependencies,
    ) {
        val file = FileSpec.builder(GENERATED_PACKAGE, DI_COMPONENT_NAME)
            .addFileComment("Generated by Stitch KSP Compiler - DO NOT EDIT")
            .addType(generateDiComponent(nodes, entryPoints))
            .build()

        val outputStream = codeGenerator.createNewFile(
            dependencies = dependencies,
            packageName = GENERATED_PACKAGE,
            fileName = DI_COMPONENT_NAME,
        )

        OutputStreamWriter(outputStream).use { writer ->
            file.writeTo(writer)
        }
    }

    private fun generateTableAdapterFile(
        nodes: List<DependencyNode>,
        entryPoints: List<EntryPointInfo>,
        dependencies: Dependencies,
    ) {
        val file = FileSpec.builder(GENERATED_PACKAGE, GENERATED_CLASS_NAME)
            .addFileComment("Generated by Stitch KSP Compiler - DO NOT EDIT")
            .addType(generateTableAdapter(nodes, entryPoints))
            .build()

        val outputStream = codeGenerator.createNewFile(
            dependencies = dependencies,
            packageName = GENERATED_PACKAGE,
            fileName = GENERATED_CLASS_NAME,
        )

        OutputStreamWriter(outputStream).use { writer ->
            file.writeTo(writer)
        }
    }

    private fun generateInitializerFile(dependencies: Dependencies) {
        val file = FileSpec.builder(GENERATED_PACKAGE, "GeneratedStitchInitializer")
            .addFileComment("Generated by Stitch KSP Compiler - DO NOT EDIT")
            .addType(generateInitializerClass())
            .build()

        val outputStream = codeGenerator.createNewFile(
            dependencies = dependencies,
            packageName = GENERATED_PACKAGE,
            fileName = "GeneratedStitchInitializer",
        )

        OutputStreamWriter(outputStream).use { writer ->
            file.writeTo(writer)
        }
    }

    private fun generateServiceLoaderConfig(dependencies: Dependencies) {
        val serviceFile = codeGenerator.createNewFile(
            dependencies = dependencies,
            packageName = "",
            fileName = "META-INF/services/com.harrytmthy.stitch.internal.StitchInitializer",
            extensionName = "",
        )

        OutputStreamWriter(serviceFile).use { writer ->
            writer.write("$GENERATED_PACKAGE.GeneratedStitchInitializer\n")
        }
    }

    /**
     * Generates StitchXxxInjector objects for performance path.
     *
     * Each class with field injection gets a dedicated injector object that implements
     * StitchInjector<T>. This enables zero-overhead field injection for performance-critical
     * code paths without requiring runtime type checking.
     *
     * Example: `StitchMainActivityInjector.inject(this)`
     */
    private fun generateInjectorObjects(entryPoints: List<EntryPointInfo>, dependencies: Dependencies) {
        val validEntryPoints = entryPoints.filter { it.injectableFields.isNotEmpty() }

        if (validEntryPoints.isEmpty()) {
            logger.info("Stitch: No field injection classes, skipping injector generation")
            return
        }

        logger.info("Stitch: Generating ${validEntryPoints.size} injector object(s)")

        validEntryPoints.forEach { entryPoint ->
            generateInjectorObject(entryPoint, dependencies)
        }
    }

    /**
     * Generates a single StitchXxxInjector object.
     */
    private fun generateInjectorObject(entryPoint: EntryPointInfo, dependencies: Dependencies) {
        val targetClassName = entryPoint.classDeclaration.toClassName()
        val injectorObjectName = "Stitch${targetClassName.simpleName}Injector"
        val componentClassName = ClassName(GENERATED_PACKAGE, DI_COMPONENT_NAME)
        val stitchInjectorInterface = ClassName("com.harrytmthy.stitch.internal", "StitchInjector")
        val injectorMethodName = "inject${targetClassName.simpleName}"

        val injectorObject = TypeSpec.objectBuilder(injectorObjectName)
            .addSuperinterface(stitchInjectorInterface.parameterizedBy(targetClassName))
            .addKdoc(
                """
                Generated injector for %T.

                Provides zero-overhead field injection by directly delegating to
                %T.$injectorMethodName() without runtime type checking.

                Usage:
                ```kotlin
                class ${targetClassName.simpleName} {
                    @Inject lateinit var dependency: SomeType

                    fun onCreate() {
                        %T.inject(this)  // Direct call, zero overhead
                    }
                }
                ```
                """.trimIndent(),
                targetClassName,
                componentClassName,
                ClassName(GENERATED_PACKAGE, injectorObjectName),
            )
            .addFunction(
                FunSpec.builder("inject")
                    .addModifiers(KModifier.OVERRIDE)
                    .addParameter("target", targetClassName)
                    .addStatement("%T.$injectorMethodName(target)", componentClassName)
                    .build(),
            )
            .build()

        val file = FileSpec.builder(GENERATED_PACKAGE, injectorObjectName)
            .addFileComment("Generated by Stitch KSP Compiler - DO NOT EDIT")
            .addType(injectorObject)
            .build()

        val outputStream = codeGenerator.createNewFile(
            dependencies = dependencies,
            packageName = GENERATED_PACKAGE,
            fileName = injectorObjectName,
        )

        OutputStreamWriter(outputStream).use { writer ->
            file.writeTo(writer)
        }

        logger.info("Stitch: Generated $injectorObjectName")
    }

    /**
     * Generates the StitchDiComponent object with direct provider methods.
     */
    private fun generateDiComponent(nodes: List<DependencyNode>, entryPoints: List<EntryPointInfo>): TypeSpec {
        val component = TypeSpec.objectBuilder(DI_COMPONENT_NAME)
            .addModifiers(KModifier.INTERNAL)

        // Collect module holders for non-object modules
        val moduleClasses = nodes
            .filter { !it.providerFunction.isConstructor() } // Only @Provides methods
            .map { it.providerModule }
            .filter { it.classKind != ClassKind.OBJECT }
            .distinctBy { it.qualifiedName?.asString() }

        if (moduleClasses.isNotEmpty()) {
            component.addType(generateModuleHolders(moduleClasses))
        }

        // Generate fields and methods for each dependency
        nodes.forEach { node ->
            // Add field and lock for singletons
            if (node.isSingleton) {
                component.addProperty(generateSingletonField(node))
                component.addProperty(generateLockField(node))
            }
            component.addFunction(generateProviderMethod(node))
        }

        // Generate entry point injectors
        entryPoints.forEach { entryPoint ->
            if (entryPoint.injectableFields.isNotEmpty()) {
                component.addFunction(generateEntryPointInjector(entryPoint))
            }
        }

        return component.build()
    }

    /**
     * Generates a @Volatile field for a singleton dependency.
     */
    private fun generateSingletonField(node: DependencyNode): PropertySpec {
        val typeCls = node.type.toClassName()
        val fieldName = "_${generateMethodName(node)}"

        return PropertySpec.builder(fieldName, typeCls.copy(nullable = true), KModifier.PRIVATE)
            .addAnnotation(Volatile::class)
            .mutable(true)
            .initializer("null")
            .build()
    }

    /**
     * Generates a lock field for a singleton dependency.
     */
    private fun generateLockField(node: DependencyNode): PropertySpec {
        val lockFieldName = "_lock_${generateMethodName(node)}"

        return PropertySpec.builder(lockFieldName, Any::class, KModifier.PRIVATE)
            .initializer("Any()")
            .build()
    }

    /**
     * Generates a provider method for a dependency.
     */
    private fun generateProviderMethod(node: DependencyNode): FunSpec {
        val typeCls = node.type.toClassName()
        val methodName = generateMethodName(node)
        val method = FunSpec.builder(methodName)
            .returns(typeCls)

        if (node.isSingleton) {
            // Singleton: double-checked locking pattern with per-binding lock
            val fieldName = "_$methodName"
            val lockName = "_lock_$methodName"
            method.addCode(
                buildCodeBlock {
                    addStatement("$fieldName?.let { return it }")
                    addStatement("synchronized($lockName) {")
                    indent()
                    addStatement("$fieldName?.let { return it }")
                    add("val v = ")
                    addProviderCall(node)
                    addStatement("$fieldName = v")
                    addStatement("return v")
                    unindent()
                    addStatement("}")
                },
            )
        } else {
            // Factory: direct call, no caching
            method.addCode(
                buildCodeBlock {
                    add("return ")
                    addProviderCall(node)
                },
            )
        }

        return method.build()
    }

    /**
     * Adds the code to create an instance (constructor call or module method call).
     */
    private fun CodeBlock.Builder.addProviderCall(node: DependencyNode) {
        val isInjectConstructor = node.providerFunction.isConstructor()

        if (isInjectConstructor) {
            // @Inject constructor
            val typeCls = node.type.toClassName()
            val constructorParamCount = node.dependencies.size - node.injectableFields.size
            val constructorParams = node.dependencies.take(constructorParamCount)

            if (constructorParams.isEmpty() && node.injectableFields.isEmpty()) {
                add("%T()\n", typeCls)
            } else {
                // Create instance with field injection
                if (constructorParams.isEmpty()) {
                    add("%T()", typeCls)
                } else {
                    add("%T(\n", typeCls)
                    indent()
                    constructorParams.forEachIndexed { i, dep ->
                        val depMethodName = generateMethodName(dep.type, dep.qualifier)
                        val comma = if (i < constructorParams.size - 1) "," else ""
                        addStatement("$depMethodName()$comma")
                    }
                    unindent()
                    add(")")
                }

                // Field injection using .also
                if (node.injectableFields.isNotEmpty()) {
                    add(".also { instance ->\n")
                    indent()
                    node.injectableFields.forEach { field ->
                        val depMethodName = generateMethodName(field.type, field.qualifier)
                        addStatement("instance.${field.name} = $depMethodName()")
                    }
                    unindent()
                    add("}\n")
                } else {
                    // No field injection, just end the statement
                    add("\n")
                }
            }
        } else {
            // @Provides method
            val moduleDecl = node.providerModule
            val moduleClass = moduleDecl.toClassName()
            val isObjectModule = moduleDecl.classKind == ClassKind.OBJECT
            val moduleAccess = if (isObjectModule) {
                "%T"
            } else {
                "_Modules._${moduleClass.simpleName.replaceFirstChar { it.lowercase() }}"
            }
            val fn = node.providerFunction.simpleName.asString()

            if (node.dependencies.isEmpty()) {
                if (isObjectModule) {
                    add("$moduleAccess.$fn()\n", moduleClass)
                } else {
                    add("$moduleAccess.$fn()\n")
                }
            } else {
                if (isObjectModule) {
                    add("$moduleAccess.$fn(\n", moduleClass)
                } else {
                    add("$moduleAccess.$fn(\n")
                }
                indent()
                node.dependencies.forEachIndexed { i, dep ->
                    val depMethodName = generateMethodName(dep.type, dep.qualifier)
                    val comma = if (i < node.dependencies.size - 1) "," else ""
                    addStatement("$depMethodName()$comma")
                }
                unindent()
                add(")\n")
            }
        }
    }

    /**
     * Generates an entry point injector method.
     */
    private fun generateEntryPointInjector(entryPoint: EntryPointInfo): FunSpec {
        val className = entryPoint.classDeclaration.toClassName()
        val methodName = "inject${className.simpleName}"

        return FunSpec.builder(methodName)
            .addParameter(ParameterSpec.builder("target", className).build())
            .addCode(
                buildCodeBlock {
                    entryPoint.injectableFields.forEach { field ->
                        val depMethodName = generateMethodName(field.type, field.qualifier)
                        addStatement("target.${field.name} = $depMethodName()")
                    }
                },
            )
            .build()
    }

    /**
     * Generates the adapter that implements DependencyTable.
     */
    private fun generateTableAdapter(nodes: List<DependencyNode>, entryPoints: List<EntryPointInfo>): TypeSpec {
        val dependencyTableType = ClassName("com.harrytmthy.stitch.internal", "DependencyTable")
        val qualifierType = ClassName("com.harrytmthy.stitch.api", "Qualifier")
        val missingBindingException = ClassName("com.harrytmthy.stitch.exception", "MissingBindingException")

        // Group nodes by type for efficient when generation
        val nodesByType = nodes.groupBy { it.type.declaration.qualifiedName?.asString() }

        return TypeSpec.objectBuilder(GENERATED_CLASS_NAME)
            .addSuperinterface(dependencyTableType)
            .addFunction(generateGetMethod(nodesByType, qualifierType, missingBindingException))
            .addFunction(generateInjectFieldsMethod(entryPoints))
            .build()
    }

    /**
     * Generates the get() method with when expressions.
     */
    private fun generateGetMethod(
        nodesByType: Map<String?, List<DependencyNode>>,
        qualifierType: ClassName,
        missingBindingException: ClassName,
    ): FunSpec {
        val typeVar = TypeVariableName("T", Any::class)

        return FunSpec.builder("get")
            .addModifiers(KModifier.OVERRIDE)
            .addTypeVariable(typeVar)
            .addParameter("type", Class::class.asClassName().parameterizedBy(typeVar))
            .addParameter("qualifier", qualifierType.copy(nullable = true))
            .returns(typeVar)
            .addCode(
                buildCodeBlock {
                    addStatement("@Suppress(\"UNCHECKED_CAST\")")
                    addStatement("return when (type) {")
                    indent()

                    nodesByType.entries.sortedBy { it.key }.forEach { (typeName, nodesForType) ->
                        if (typeName == null) return@forEach

                        val firstNode = nodesForType.first()
                        val typeCls = firstNode.type.toClassName()

                        if (nodesForType.size == 1 && firstNode.qualifier == null) {
                            // Simple case: single unqualified binding
                            val methodName = generateMethodName(firstNode)
                            addStatement("%T::class.java -> $DI_COMPONENT_NAME.$methodName() as %T", typeCls, typeVar)
                        } else {
                            // Multiple qualifiers for this type
                            addStatement("%T::class.java -> {", typeCls)
                            indent()
                            addStatement("when (qualifier) {")
                            indent()

                            nodesForType.sortedBy { it.qualifier?.toString() }.forEach { node ->
                                val methodName = generateMethodName(node)
                                if (node.qualifier == null) {
                                    addStatement("null -> $DI_COMPONENT_NAME.$methodName() as %T", typeVar)
                                } else {
                                    val qualCode = node.qualifier.toCode()
                                    addStatement("$qualCode -> $DI_COMPONENT_NAME.$methodName() as %T", typeVar)
                                }
                            }

                            // Missing qualifier case
                            add("else -> throw %T.missingQualifier(type, qualifier, listOf(", missingBindingException)
                            nodesForType.forEachIndexed { i, node ->
                                if (node.qualifier == null) {
                                    add("null")
                                } else {
                                    add(node.qualifier.toCode())
                                }
                                if (i < nodesForType.size - 1) add(", ")
                            }
                            addStatement("))")

                            unindent()
                            addStatement("}")
                            unindent()
                            addStatement("}")
                        }
                    }

                    addStatement("else -> throw %T.missingType(type)", missingBindingException)
                    unindent()
                    addStatement("}")
                },
            )
            .build()
    }

    /**
     * Generates the `injectFields()` method using instanceof checks for optimal performance.
     *
     * Uses `when (instance)` with `is` checks instead of class equality checks. This compiles
     * to JVM instanceof instructions which are:
     * - Faster (1-2 CPU instructions each)
     * - JIT-optimizable via type guard chains
     * - Support inheritance (unlike HashMap or class equality)
     */
    private fun generateInjectFieldsMethod(entryPoints: List<EntryPointInfo>): FunSpec {
        val typeVar = TypeVariableName("T", Any::class)

        return FunSpec.builder("injectFields")
            .addModifiers(KModifier.OVERRIDE)
            .addTypeVariable(typeVar)
            .addParameter("instance", typeVar)
            .addCode(
                buildCodeBlock {
                    if (entryPoints.isEmpty() || entryPoints.none { it.injectableFields.isNotEmpty() }) {
                        // No entry points - no-op
                        addStatement("// No classes with field injection")
                        return@buildCodeBlock
                    }

                    addStatement("when (instance) {")
                    indent()

                    entryPoints.filter { it.injectableFields.isNotEmpty() }.forEach { entryPoint ->
                        val className = entryPoint.classDeclaration.toClassName()
                        val methodName = "inject${className.simpleName}"
                        addStatement("is %T -> $DI_COMPONENT_NAME.$methodName(instance)", className)
                    }

                    addStatement("else -> Unit // No-op for other types")
                    unindent()
                    addStatement("}")
                },
            )
            .build()
    }

    private fun generateModuleHolders(moduleClasses: List<KSClassDeclaration>): TypeSpec {
        val type = TypeSpec.objectBuilder("_Modules").addModifiers(KModifier.PRIVATE)
        moduleClasses.forEach { m ->
            val className = m.toClassName()
            val propName = "_${className.simpleName.replaceFirstChar { it.lowercase() }}"
            type.addProperty(
                PropertySpec.builder(propName, className)
                    .initializer("%T()", className)
                    .addModifiers(KModifier.INTERNAL)
                    .build(),
            )
        }
        return type.build()
    }

    private fun generateInitializerClass(): TypeSpec {
        val initializerType = ClassName("com.harrytmthy.stitch.internal", "StitchInitializer")
        val dependencyTableType = ClassName("com.harrytmthy.stitch.internal", "DependencyTable")

        return TypeSpec.classBuilder("GeneratedStitchInitializer")
            .addSuperinterface(initializerType)
            .addKdoc(
                """
                ServiceLoader provider for compile-time generated dependency table.

                This class is automatically discovered and loaded by Stitch via ServiceLoader.
                No manual initialization required.
                """.trimIndent(),
            )
            .addFunction(
                FunSpec.builder("getDependencyTable")
                    .addModifiers(KModifier.OVERRIDE)
                    .returns(dependencyTableType)
                    .addCode("return $GENERATED_CLASS_NAME")
                    .build(),
            )
            .build()
    }

    /**
     * Generates a method name for a dependency.
     * Format: {typeName} for unqualified, {typeName}_named_{value} for Named qualifiers
     */
    private fun generateMethodName(node: DependencyNode): String {
        return generateMethodName(node.type, node.qualifier)
    }

    private fun generateMethodName(type: KSType, qualifier: QualifierInfo?): String {
        val typeName = type.declaration.simpleName.asString()
        val baseName = typeName.replaceFirstChar { it.lowercase() }

        return when (qualifier) {
            null -> baseName
            is QualifierInfo.Named -> "${baseName}_named_${sanitizeName(qualifier.value)}"
            is QualifierInfo.Custom -> error("Custom qualifiers not supported in v1.0")
        }
    }

    private fun sanitizeName(name: String): String {
        return name.replace(Regex("[^a-zA-Z0-9]"), "_")
    }

    private fun KSType.toClassName(): ClassName {
        val declaration = this.declaration
        val packageName = declaration.packageName.asString()
        val simpleName = declaration.simpleName.asString()
        return ClassName(packageName, simpleName)
    }

    private fun KSClassDeclaration.toClassName(): ClassName {
        val packageName = this.packageName.asString()
        val simpleName = this.simpleName.asString()
        return ClassName(packageName, simpleName)
    }

    private fun QualifierInfo.toCode(): String =
        when (this) {
            is QualifierInfo.Named -> "com.harrytmthy.stitch.api.named(${this.value.quote()})"
            is QualifierInfo.Custom -> error("Custom qualifiers are not supported in v1.0")
        }

    private fun String.quote(): String =
        buildString {
            append('"')
            for (ch in this@quote) {
                when (ch) {
                    '\\' -> append("\\\\")
                    '"' -> append("\\\"")
                    '\n' -> append("\\n")
                    '\r' -> append("\\r")
                    '\t' -> append("\\t")
                    else -> append(ch)
                }
            }
            append('"')
        }

    /**
     * Extension to check if a KSFunctionDeclaration is a constructor.
     */
    private fun KSFunctionDeclaration.isConstructor() = this.simpleName.asString() == "<init>"
}
