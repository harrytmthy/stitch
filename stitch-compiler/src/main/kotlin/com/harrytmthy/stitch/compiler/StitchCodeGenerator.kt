/*
 * Copyright 2025 Harry Timothy Tumalewa
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.harrytmthy.stitch.compiler

import com.google.devtools.ksp.isConstructor
import com.google.devtools.ksp.processing.Dependencies
import com.google.devtools.ksp.processing.KSPLogger
import com.google.devtools.ksp.symbol.ClassKind
import com.google.devtools.ksp.symbol.KSClassDeclaration
import com.google.devtools.ksp.symbol.KSType
import com.squareup.kotlinpoet.ClassName
import com.squareup.kotlinpoet.CodeBlock
import com.squareup.kotlinpoet.FileSpec
import com.squareup.kotlinpoet.FunSpec
import com.squareup.kotlinpoet.KModifier
import com.squareup.kotlinpoet.ParameterSpec
import com.squareup.kotlinpoet.ParameterizedTypeName.Companion.parameterizedBy
import com.squareup.kotlinpoet.PropertySpec
import com.squareup.kotlinpoet.TypeSpec
import com.squareup.kotlinpoet.buildCodeBlock
import com.squareup.kotlinpoet.ksp.toTypeName
import java.io.OutputStreamWriter
import com.google.devtools.ksp.processing.CodeGenerator as KspCodeGenerator

/**
 * Generates the DI implementation using direct method calls (Dagger-style).
 */
class StitchCodeGenerator(
    private val codeGenerator: KspCodeGenerator,
    private val logger: KSPLogger,
) {

    fun generateComponentAndInjector(nodes: List<DependencyNode>, fieldInjectors: List<FieldInjectorInfo>) {
        logger.info("Stitch: Generating DI component with ${nodes.size} bindings and ${fieldInjectors.size} injectors")

        val dependencies = Dependencies(
            aggregating = true,
            sources = nodes.flatMap { listOf(it.providerModule.containingFile, it.providerFunction.containingFile) }
                .plus(fieldInjectors.map { it.classDeclaration.containingFile })
                .filterNotNull()
                .distinct()
                .toTypedArray(),
        )

        // Generate DI component file
        generateDiComponentFile(nodes, fieldInjectors, dependencies)

        // Generate StitchXxxInjector objects
        generateInjectorObjects(fieldInjectors, dependencies)

        logger.info("Stitch: Generated StitchDiComponent and injector objects")
    }

    private fun generateDiComponentFile(
        nodes: List<DependencyNode>,
        fieldInjectors: List<FieldInjectorInfo>,
        dependencies: Dependencies,
    ) {
        val file = FileSpec.builder(GENERATED_PACKAGE, DI_COMPONENT_NAME)
            .addFileComment("Generated by Stitch KSP Compiler - DO NOT EDIT")
            .addType(generateDiComponent(nodes, fieldInjectors))
            .build()

        val outputStream = codeGenerator.createNewFile(
            dependencies = dependencies,
            packageName = GENERATED_PACKAGE,
            fileName = DI_COMPONENT_NAME,
        )

        OutputStreamWriter(outputStream).use { writer ->
            file.writeTo(writer)
        }
    }

    /**
     * Generates StitchXxxInjector objects for performance path.
     *
     * Each class with field injection gets a dedicated injector object that implements
     * StitchInjector<T>. This enables zero-overhead field injection for performance-critical
     * code paths without requiring runtime type checking.
     *
     * Example: `StitchMainActivityInjector.inject(this)`
     */
    private fun generateInjectorObjects(fieldInjectors: List<FieldInjectorInfo>, dependencies: Dependencies) {
        val fieldInjectors = fieldInjectors.filter { it.injectableFields.isNotEmpty() }

        if (fieldInjectors.isEmpty()) {
            logger.info("Stitch: No field injection classes, skipping injector generation")
            return
        }

        logger.info("Stitch: Generating ${fieldInjectors.size} injector object(s)")

        for (fieldInjector in fieldInjectors) {
            generateInjectorObject(fieldInjector, dependencies)
        }
    }

    /**
     * Generates a single StitchXxxInjector object.
     */
    private fun generateInjectorObject(fieldInjector: FieldInjectorInfo, dependencies: Dependencies) {
        val targetClassName = fieldInjector.classDeclaration.toClassName()
        val injectorObjectName = "Stitch${targetClassName.simpleName}Injector"
        val componentClassName = ClassName(GENERATED_PACKAGE, DI_COMPONENT_NAME)
        val stitchInjectorInterface = ClassName("com.harrytmthy.stitch.internal", "StitchInjector")
        val injectorMethodName = "inject${targetClassName.simpleName}"

        val injectorObject = TypeSpec.objectBuilder(injectorObjectName)
            .addSuperinterface(stitchInjectorInterface.parameterizedBy(targetClassName))
            .addKdoc(
                """
                Generated injector for %T.

                Provides zero-overhead field injection by directly delegating to
                %T.$injectorMethodName() without runtime type checking.

                Usage:
                ```kotlin
                class ${targetClassName.simpleName} {
                    @Inject lateinit var dependency: SomeType

                    fun onCreate() {
                        %T.inject(this)  // Direct call, zero overhead
                    }
                }
                ```
                """.trimIndent(),
                targetClassName,
                componentClassName,
                ClassName(GENERATED_PACKAGE, injectorObjectName),
            )
            .addFunction(
                FunSpec.builder("inject")
                    .addModifiers(KModifier.OVERRIDE)
                    .addParameter("target", targetClassName)
                    .addStatement("%T.$injectorMethodName(target)", componentClassName)
                    .build(),
            )
            .build()

        val file = FileSpec.builder(GENERATED_PACKAGE, injectorObjectName)
            .addFileComment("Generated by Stitch KSP Compiler - DO NOT EDIT")
            .addType(injectorObject)
            .build()

        val outputStream = codeGenerator.createNewFile(
            dependencies = dependencies,
            packageName = GENERATED_PACKAGE,
            fileName = injectorObjectName,
        )

        OutputStreamWriter(outputStream).use { writer ->
            file.writeTo(writer)
        }

        logger.info("Stitch: Generated $injectorObjectName")
    }

    /**
     * Generates the StitchDiComponent object with direct provider methods.
     */
    private fun generateDiComponent(
        nodes: List<DependencyNode>,
        fieldInjectors: List<FieldInjectorInfo>,
    ): TypeSpec {
        val component = TypeSpec.objectBuilder(DI_COMPONENT_NAME)
            .addModifiers(KModifier.INTERNAL)

        // Collect module holders for non-object modules
        val moduleClasses = nodes
            .filter { !it.providerFunction.isConstructor() } // Only @Provides methods
            .map { it.providerModule }
            .filter { it.classKind != ClassKind.OBJECT }
            .distinctBy { it.qualifiedName?.asString() }

        if (moduleClasses.isNotEmpty()) {
            component.addType(generateModuleHolders(moduleClasses))
        }

        // Generate fields and methods for each dependency
        nodes.forEach { node ->
            // Add field and lock for singletons (only for canonical type, not aliases)
            if (node.isSingleton) {
                component.addProperty(generateSingletonField(node))
                component.addProperty(generateInitializedFlag(node))
                component.addProperty(generateLockField(node))
            }

            // Generate canonical provider method
            component.addFunction(generateProviderMethod(node))

            // Generate alias provider methods that delegate to canonical method
            node.aliases.forEach { aliasType ->
                component.addFunction(generateAliasProviderMethod(node, aliasType))
            }
        }

        // Generate field injectors
        fieldInjectors.forEach { fieldInjector ->
            if (fieldInjector.injectableFields.isNotEmpty()) {
                component.addFunction(generateFieldInjector(fieldInjector))
            }
        }

        return component.build()
    }

    /**
     * Generates a @Volatile field for a singleton dependency.
     */
    private fun generateSingletonField(node: DependencyNode): PropertySpec {
        val typeCls = node.type.toTypeName()
        val fieldName = "_${generateMethodName(node)}"

        return PropertySpec.builder(fieldName, typeCls.copy(nullable = true), KModifier.PRIVATE)
            .addAnnotation(Volatile::class)
            .mutable(true)
            .initializer("null")
            .build()
    }

    /**
     * Generates an initialized flag for singleton dependencies.
     */
    private fun generateInitializedFlag(node: DependencyNode): PropertySpec {
        val flagName = "_${generateMethodName(node)}_initialized"

        return PropertySpec.builder(flagName, Boolean::class, KModifier.PRIVATE)
            .addAnnotation(Volatile::class)
            .mutable(true)
            .initializer("false")
            .build()
    }

    /**
     * Generates a lock field for a singleton dependency.
     */
    private fun generateLockField(node: DependencyNode): PropertySpec {
        val lockFieldName = "_lock_${generateMethodName(node)}"

        return PropertySpec.builder(lockFieldName, Any::class, KModifier.PRIVATE)
            .initializer("Any()")
            .build()
    }

    /**
     * Generates an alias provider method that delegates to the canonical provider.
     */
    private fun generateAliasProviderMethod(node: DependencyNode, aliasType: KSType): FunSpec {
        val aliasTypeCls = aliasType.toTypeName()
        val canonicalMethodName = generateMethodName(node)
        val aliasMethodName = generateMethodName(aliasType, node.qualifier)

        return FunSpec.builder(aliasMethodName)
            .returns(aliasTypeCls)
            .addStatement("return $canonicalMethodName()")
            .build()
    }

    /**
     * Generates a provider method for a dependency.
     */
    private fun generateProviderMethod(node: DependencyNode): FunSpec {
        val typeCls = node.type.toTypeName()
        val methodName = generateMethodName(node)
        val method = FunSpec.builder(methodName)
            .returns(typeCls)

        if (node.isSingleton) {
            // Singleton: double-checked locking pattern with initialized flag
            val fieldName = "_$methodName"
            val initFlagName = "${fieldName}_initialized"
            val lockName = "_lock_$methodName"
            // Field is stored as nullable, need !! for non-nullable return types
            val fieldReturn = if (node.type.isMarkedNullable) fieldName else "$fieldName!!"
            method.addCode(
                buildCodeBlock {
                    addStatement("if ($initFlagName) return $fieldReturn")
                    addStatement("synchronized($lockName) {")
                    indent()
                    addStatement("if ($initFlagName) return $fieldReturn")
                    add("val v = ")
                    addProviderCall(node)
                    addStatement("$fieldName = v")
                    addStatement("$initFlagName = true")
                    addStatement("return v")
                    unindent()
                    addStatement("}")
                },
            )
        } else {
            // Factory: direct call, no caching
            method.addCode(
                buildCodeBlock {
                    add("return ")
                    addProviderCall(node)
                },
            )
        }

        return method.build()
    }

    /**
     * Adds the code to create an instance (constructor call or module method call).
     */
    private fun CodeBlock.Builder.addProviderCall(node: DependencyNode) {
        val isInjectConstructor = node.providerFunction.isConstructor()

        if (isInjectConstructor) {
            // @Inject constructor
            val typeCls = node.type.toClassName()
            val constructorParamCount = node.dependencies.size - node.injectableFields.size
            val constructorParams = node.dependencies.take(constructorParamCount)

            if (constructorParams.isEmpty() && node.injectableFields.isEmpty()) {
                add("%T()\n", typeCls)
            } else {
                // Create instance with field injection
                if (constructorParams.isEmpty()) {
                    add("%T()", typeCls)
                } else {
                    add("%T(\n", typeCls)
                    indent()
                    constructorParams.forEachIndexed { i, dep ->
                        val depMethodName = generateMethodName(dep.type, dep.qualifier)
                        val comma = if (i < constructorParams.size - 1) "," else ""
                        addStatement("$depMethodName()$comma")
                    }
                    unindent()
                    add(")")
                }

                // Field injection using .also
                if (node.injectableFields.isNotEmpty()) {
                    add(".also { instance ->\n")
                    indent()
                    node.injectableFields.forEach { field ->
                        val depMethodName = generateMethodName(field.type, field.qualifier)
                        addStatement("instance.${field.name} = $depMethodName()")
                    }
                    unindent()
                    add("}\n")
                } else {
                    // No field injection, just end the statement
                    add("\n")
                }
            }
        } else {
            // @Provides method
            val module = node.providerModule
            val moduleClass = module.toClassName()
            val isObjectModule = module.classKind == ClassKind.OBJECT
            val moduleAccess = if (isObjectModule) {
                "%T"
            } else {
                "_Modules._${moduleClass.simpleName.replaceFirstChar { it.lowercase() }}"
            }
            val fn = node.providerFunction.simpleName.asString()

            if (node.dependencies.isEmpty()) {
                if (isObjectModule) {
                    add("$moduleAccess.$fn()\n", moduleClass)
                } else {
                    add("$moduleAccess.$fn()\n")
                }
            } else {
                if (isObjectModule) {
                    add("$moduleAccess.$fn(\n", moduleClass)
                } else {
                    add("$moduleAccess.$fn(\n")
                }
                indent()
                node.dependencies.forEachIndexed { i, dep ->
                    val depMethodName = generateMethodName(dep.type, dep.qualifier)
                    val comma = if (i < node.dependencies.size - 1) "," else ""
                    addStatement("$depMethodName()$comma")
                }
                unindent()
                add(")\n")
            }
        }
    }

    /**
     * Generates a field injector method for a class with @Inject fields.
     */
    private fun generateFieldInjector(fieldInjector: FieldInjectorInfo): FunSpec {
        val className = fieldInjector.classDeclaration.toClassName()
        val methodName = "inject${className.simpleName}"

        return FunSpec.builder(methodName)
            .addParameter(ParameterSpec.builder("target", className).build())
            .addCode(
                buildCodeBlock {
                    fieldInjector.injectableFields.forEach { field ->
                        val depMethodName = generateMethodName(field.type, field.qualifier)
                        addStatement("target.${field.name} = $depMethodName()")
                    }
                },
            )
            .build()
    }

    private fun generateModuleHolders(moduleClasses: List<KSClassDeclaration>): TypeSpec {
        val type = TypeSpec.objectBuilder("_Modules").addModifiers(KModifier.PRIVATE)
        moduleClasses.forEach { m ->
            val className = m.toClassName()
            val propName = "_${className.simpleName.replaceFirstChar { it.lowercase() }}"
            type.addProperty(
                PropertySpec.builder(propName, className)
                    .initializer("%T()", className)
                    .addModifiers(KModifier.INTERNAL)
                    .build(),
            )
        }
        return type.build()
    }

    /**
     * Generates a method name for a dependency.
     * Format: {typeName} for unqualified, {typeName}_named_{value} for Named qualifiers
     */
    private fun generateMethodName(node: DependencyNode): String {
        return generateMethodName(node.type, node.qualifier)
    }

    private fun generateMethodName(type: KSType, qualifier: QualifierInfo?): String {
        val typeName = type.declaration.simpleName.asString()
        val baseName = typeName.replaceFirstChar { it.lowercase() }

        return when (qualifier) {
            null -> baseName
            is QualifierInfo.Named -> "${baseName}_named_${sanitizeName(qualifier.value)}"
            is QualifierInfo.Custom -> error("Custom qualifiers not supported in v1.0")
        }
    }

    private fun sanitizeName(name: String): String {
        return name.replace(Regex("[^a-zA-Z0-9]"), "_")
    }

    private fun KSType.toClassName(): ClassName {
        val declaration = this.declaration
        val packageName = declaration.packageName.asString()
        val simpleName = declaration.simpleName.asString()
        return ClassName(packageName, simpleName)
    }

    private fun KSClassDeclaration.toClassName(): ClassName {
        val packageName = this.packageName.asString()
        val simpleName = this.simpleName.asString()
        return ClassName(packageName, simpleName)
    }

    private fun QualifierInfo.toCode(): String =
        when (this) {
            is QualifierInfo.Named -> "com.harrytmthy.stitch.api.named(${this.value.quote()})"
            is QualifierInfo.Custom -> error("Custom qualifiers are not supported in v1.0")
        }

    private fun String.quote(): String =
        buildString {
            append('"')
            for (ch in this@quote) {
                when (ch) {
                    '\\' -> append("\\\\")
                    '"' -> append("\\\"")
                    '\n' -> append("\\n")
                    '\r' -> append("\\r")
                    '\t' -> append("\\t")
                    else -> append(ch)
                }
            }
            append('"')
        }

    private companion object {
        const val GENERATED_PACKAGE = "com.harrytmthy.stitch.generated"
        const val DI_COMPONENT_NAME = "StitchDiComponent"
    }
}
